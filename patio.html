<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pátio - Bronzify</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#B76E79">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Bronzify">
    <link rel="apple-touch-icon" href="apple-touch-icon.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700&family=Poppins:wght@400;500;600&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>

    <style>
        body { font-family: 'Poppins', sans-serif; background-color: #FFF9F9; }
        h1, h2, h3, h4 { font-family: 'Playfair Display', serif; }
        .sidebar-link { display: flex; align-items: center; padding: 0.75rem 1.25rem; border-radius: 0.75rem; color: #4A5568; transition: all 0.3s ease; font-weight: 500; }
        .sidebar-link:hover, .sidebar-link.active { background-color: #FADADD; color: #B76E79; }
        .sidebar-link svg { margin-right: 0.75rem; }
        .patio-card { transition: opacity 0.5s ease, transform 0.5s ease, box-shadow 0.3s ease; }
        .patio-card.removing { opacity: 0; transform: scale(0.95); }
        .patio-card.needs-attention { box-shadow: 0 0 0 4px #FBBF24; animation: pulse 1.5s infinite; }
        @keyframes pulse { 0% { box-shadow: 0 0 0 0px rgba(251, 191, 36, 0.7); } 100% { box-shadow: 0 0 0 10px rgba(251, 191, 36, 0); } }
        .sidebar-mobile { transform: translateX(-100%); transition: transform 0.3s ease-in-out; }
        .sidebar-mobile.open { transform: translateX(0); }

        /* --- NOVO: Estilos para o modal de confirmação --- */
        .modal-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex; align-items: center; justify-content: center;
            z-index: 50; opacity: 0; transition: opacity 0.3s ease; pointer-events: none;
        }
        .modal-overlay.visible { opacity: 1; pointer-events: auto; }
        .modal-content {
            background-color: white; padding: 2rem; border-radius: 1rem;
            width: 90%; max-width: 400px; text-align: center;
            transform: scale(0.95); transition: transform 0.3s ease;
        }
        .modal-overlay.visible .modal-content { transform: scale(1); }
    </style>
</head>
<body class="bg-gray-50">

    <div class="flex h-screen">
        <main class="flex-1 p-4 sm:p-8 overflow-y-auto">
            <header class="flex flex-col sm:flex-row justify-between items-center mb-8 gap-4">
                <div class="flex items-center w-full">
                    <button id="open-menu-btn" class="lg:hidden p-2 -ml-2"><i data-lucide="menu" class="w-6 h-6 text-gray-800"></i></button>
                    <h2 class="text-3xl lg:text-4xl text-gray-800 w-full text-center sm:text-left">Pátio</h2>
                </div>
                <button id="help-btn" class="w-full sm:w-auto bg-amber-500 text-white px-4 py-2 rounded-lg hover:bg-amber-600 flex items-center justify-center gap-2 flex-shrink-0">
                    <i data-lucide="bell-ring"></i> Pedir Ajuda
                </button>
            </header>

            <div id="patio-list" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6"></div>
            
            <div id="no-clients-patio" class="text-center py-16 text-gray-500 hidden">
                <i data-lucide="sun" class="mx-auto w-16 h-16 mb-4"></i>
                <p class="text-xl">O pátio está vazio no momento.</p>
            </div>
        </main>
    </div>

    <div id="custom-confirm-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 id="confirm-title" class="text-2xl font-bold text-gray-800 mb-4">MUDANÇA DE POSIÇÃO</h3>
            <p id="confirm-message" class="text-gray-600 mb-6">Instrução para o usuário.</p>
            <div class="flex justify-center gap-4">
                <button id="confirm-btn" class="bg-green-500 text-white px-8 py-2 rounded-lg hover:bg-green-600">Confirmar</button>
            </div>
        </div>
    </div>

    <script>
      lucide.createIcons();
    </script>
    <script src="./config.js"></script>
    <script type="module" src="./layout.js"></script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
        import { getFirestore, collection, query, onSnapshot, orderBy, doc, updateDoc, getDocs, Timestamp, addDoc } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        
        let currentUser = null;
        let allProducts = [];
        let synth = null;
        let localIntervals = {};
        let activeModals = new Set();

        // --- NOVO: LÓGICA DO MODAL CONTROLÁVEL ---
        const modalElement = document.getElementById('custom-confirm-modal');
        const confirmTitle = document.getElementById('confirm-title');
        const confirmMessage = document.getElementById('confirm-message');
        const confirmBtn = document.getElementById('confirm-btn');
        let confirmPromiseResolver = null;

        function showConfirm(message, title = 'Confirmação', btnText = 'Confirmar') {
            confirmTitle.textContent = title;
            confirmMessage.textContent = message;
            confirmBtn.textContent = btnText;
            modalElement.classList.add('visible');
            return new Promise((resolve) => {
                confirmPromiseResolver = resolve;
            });
        }

        function closeConfirm(resolutionValue = false) {
            if (confirmPromiseResolver) {
                confirmPromiseResolver(resolutionValue);
                confirmPromiseResolver = null;
            }
            modalElement.classList.remove('visible');
        }
        confirmBtn.addEventListener('click', () => closeConfirm(true));
        // --- Fim da lógica do modal ---

        const TANNING_PHASES = [
            { name: "Frente", image: "frente.png", instruction: "Por favor, posicione a cliente de FRENTE." },
            { name: "Costas", image: "costas.png", instruction: "Por favor, posicione a cliente de COSTAS." },
            { name: "Lado Esquerdo", image: "lado_esquerdo.png", instruction: "Por favor, posicione a cliente de LADO ESQUERDO." },
            { name: "Lado Direito", image: "lado_direito.png", instruction: "Por favor, posicione a cliente de LADO DIREITO." },
        ];

        async function initializeAudio() { if (Tone.context.state !== 'running') { await Tone.start(); } if (!synth) { synth = new Tone.Synth().toDestination(); } }
        onAuthStateChanged(auth, (user) => { if (user) { currentUser = user; loadProductsAndListenForClients(); } else { window.location.href = './index.html'; } });
        async function loadProductsAndListenForClients() { if (!currentUser) return; try { const productsRef = collection(db, "businesses", currentUser.uid, "products"); const productsSnapshot = await getDocs(productsRef); allProducts = productsSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })); listenForPatioClients(); } catch (error) { console.error("Erro ao carregar produtos:", error); } }
        
        const patioListContainer = document.getElementById('patio-list');
        const noClientsMessage = document.getElementById('no-clients-patio');

        function listenForPatioClients() {
            if (!currentUser) return;
            const todayStart = new Date(); todayStart.setHours(0, 0, 0, 0);
            const salesRef = collection(db, "businesses", currentUser.uid, "sales");
            const q = query(salesRef, orderBy("createdAt", "asc"));

            onSnapshot(q, (querySnapshot) => {
                const patioClients = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })).filter(sale => sale.status === 'called' && sale.createdAt.toDate() >= todayStart);

                // --- ALTERADO: LÓGICA PARA FECHAR MODAL OBSOLETO ---
                patioClients.forEach(sale => {
                    // Se um modal está aberto para esta venda E o estado dela já não é mais 'paused',
                    // significa que outro dispositivo confirmou. Então, fechamos o modal local.
                    if (activeModals.has(sale.id) && sale.timerState?.status !== 'paused') {
                        closeConfirm(false); // Fecha o modal, resolvendo a promessa com 'false'
                        activeModals.delete(sale.id); // Remove do nosso controle local
                    }
                });

                noClientsMessage.classList.toggle('hidden', patioClients.length > 0);
                const existingCards = new Set(Array.from(patioListContainer.children).map(c => c.id));
                const clientsOnScreen = new Set(patioClients.map(c => `sale-${c.id}`));

                existingCards.forEach(cardId => {
                    if (!clientsOnScreen.has(cardId)) {
                        const cleanId = cardId.replace('sale-', '');
                        document.getElementById(cardId)?.remove();
                        if (localIntervals[cleanId]) clearInterval(localIntervals[cleanId]);
                        delete localIntervals[cleanId];
                    }
                });

                patioClients.forEach((sale) => {
                    let card = document.getElementById(`sale-${sale.id}`);
                    if (!card) { card = createClientCard(sale); patioListContainer.appendChild(card); }
                    updateClientCard(sale);
                });
                lucide.createIcons();
            });
        }

        function updateClientCard(sale) {
            const card = document.getElementById(`sale-${sale.id}`); if (!card) return;
            // (Código de exibição de detalhes, sem alterações)
            const bronzeItems = [], consumableItems = [], extraItems = []; if (sale.items && Array.isArray(sale.items)) { sale.items.forEach(saleItem => { const productDetails = allProducts.find(p => saleItem.name.startsWith(p.name)); const itemName = saleItem.quantity > 1 ? `${saleItem.name} (x${saleItem.quantity})` : saleItem.name; if (productDetails) { if (productDetails.category === 'bronze') bronzeItems.push(itemName); else if (productDetails.category === 'consumable') consumableItems.push(itemName); else if (productDetails.category === 'extra') extraItems.push(itemName); } else if (saleItem.name.includes('(Pacote')) { bronzeItems.push(saleItem.name); } }); } card.querySelector('.client-details').innerHTML = ` <h3 class="text-2xl text-gray-800 font-bold mb-4">${sale.clientName}</h3> ${bronzeItems.length > 0 ? `<div class="mb-3"><h4 class="font-semibold text-sm text-[#B76E79] mb-1">Bronze</h4><p class="text-gray-600 text-sm">${bronzeItems.join(', ')}</p></div>` : ''} ${consumableItems.length > 0 ? `<div class="mb-3"><h4 class="font-semibold text-sm text-[#B76E79] mb-1">Consumo</h4><p class="text-gray-600 text-sm">${consumableItems.join(', ')}</p></div>` : ''} ${extraItems.length > 0 ? `<div class="mb-3"><h4 class="font-semibold text-sm text-[#B76E79] mb-1">Adicionais</h4><p class="text-gray-600 text-sm">${extraItems.join(', ')}</p></div>` : ''} `;
            
            if (localIntervals[sale.id]) clearInterval(localIntervals[sale.id]);
            if (sale.timerState) { handleTimerState(sale); } else { resetCardUIToIdle(sale.id); }
        }

        function handleTimerState(sale) {
            const { timerState, id: saleId } = sale;
            if (!timerState || timerState.status === 'idle') { resetCardUIToIdle(saleId); return; }

            updateCardUIToRunning(saleId, timerState);
            document.getElementById(`sale-${saleId}`).classList.toggle('needs-attention', timerState.status === 'paused');

            if (timerState.status === 'finished') { updateCardUIToFinished(saleId); return; }

            // --- ALTERADO: Dispara a abertura do modal em todos os aparelhos ---
            // Se o estado é 'paused' e ainda não há um modal ativo NESTE aparelho, mostre-o.
            if (timerState.status === 'paused' && !activeModals.has(saleId)) {
                triggerConfirmationFlow(sale);
            }
            
            if (timerState.status === 'running') {
                const phase = TANNING_PHASES[timerState.currentPhase];
                document.getElementById(`phase-display-${saleId}`).textContent = phase.name;
                const imageDisplay = document.getElementById(`image-display-${saleId}`);
                imageDisplay.src = phase.image; imageDisplay.alt = phase.name; imageDisplay.classList.remove('hidden');

                localIntervals[saleId] = setInterval(() => {
                    const latestSaleState = sale.timerState; // Usa o estado mais recente
                    if (!latestSaleState || latestSaleState.status !== 'running') { clearInterval(localIntervals[saleId]); return; }
                    
                    const timeElapsed = Math.round((Date.now() - latestSaleState.phaseStartedAt.toMillis()) / 1000);
                    let timeLeft = latestSaleState.phaseDurationSeconds - timeElapsed;
                    if (timeLeft < 0) timeLeft = 0;
                    
                    const minutes = Math.floor(timeLeft / 60); const seconds = timeLeft % 60;
                    const display = document.getElementById(`timer-display-${saleId}`);
                    if (display) display.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;

                    if (timeLeft <= 0) {
                        clearInterval(localIntervals[saleId]);
                        handlePhaseEnd(sale);
                    }
                }, 1000);
            }
        }

        // --- ALTERADO: Função só atualiza o status, não mostra mais o modal ---
        async function handlePhaseEnd(sale) {
            const { id: saleId, timerState } = sale;
            // Previne que múltiplos timers locais disparem a função
            if (timerState.status !== 'running') return; 
            
            // Toca o som apenas no dispositivo que disparou o fim do timer
            await initializeAudio();
            if (synth) {
                synth.triggerAttackRelease("G5", "8n", Tone.now());
                synth.triggerAttackRelease("G5", "8n", Tone.now() + 0.2);
            }
            showLocalNotification("Hora de virar!", `${sale.clientName} terminou uma fase.`);

            // A única responsabilidade é ATUALIZAR O ESTADO CENTRAL
            const saleRef = doc(db, "businesses", currentUser.uid, "sales", saleId);
            await updateDoc(saleRef, { "timerState.status": "paused" });
        }
        
        // --- NOVO: Função que agora controla o fluxo de confirmação ---
        async function triggerConfirmationFlow(sale) {
            const { id: saleId, clientName, timerState } = sale;
            activeModals.add(saleId);

            const nextPhaseIndex = timerState.currentPhase + 1;
            const isFinished = nextPhaseIndex >= TANNING_PHASES.length;
            const modalInstruction = isFinished 
                ? `${clientName} finalizou todas as posições!`
                : TANNING_PHASES[nextPhaseIndex].instruction;

            const confirmed = await showConfirm(modalInstruction, 'MUDANÇA DE POSIÇÃO', 'Confirmar');
            
            // Somente o aparelho que clicou em "Confirmar" fará a atualização
            if (confirmed) {
                const saleRef = doc(db, "businesses", currentUser.uid, "sales", saleId);
                const updateData = isFinished
                    ? { "timerState.status": "finished" }
                    : { "timerState.currentPhase": nextPhaseIndex, "timerState.phaseStartedAt": Timestamp.now(), "timerState.status": "running" };
                await updateDoc(saleRef, updateData);
            }
            
            // Limpa o controle do modal neste aparelho
            activeModals.delete(saleId);
        }

        function resetCardUIToIdle(saleId) { const card = document.getElementById(`sale-${saleId}`); if (!card) return; card.querySelector('.time-select').disabled = false; const startButton = card.querySelector('.start-timer-btn'); startButton.disabled = false; startButton.classList.remove('bg-gray-400'); startButton.classList.add('bg-green-500'); startButton.innerHTML = `<i data-lucide="play" class="w-5 h-5"></i> Iniciar Timer`; lucide.createIcons(); }
        function updateCardUIToRunning(saleId, timerState) { const card = document.getElementById(`sale-${saleId}`); if(!card) return; const timeSelect = card.querySelector('.time-select'); timeSelect.disabled = timerState.currentPhase > 0; timeSelect.value = timerState.phaseDurationSeconds / 60; const startButton = card.querySelector('.start-timer-btn'); startButton.disabled = true; startButton.innerHTML = `<i data-lucide="timer" class="w-5 h-5"></i> Em Andamento`; lucide.createIcons(); }
        function updateCardUIToFinished(saleId) { const card = document.getElementById(`sale-${saleId}`); if(!card) return; const timerState = { currentPhase: 99, phaseDurationSeconds: 0 }; updateCardUIToRunning(saleId, timerState); const display = document.getElementById(`timer-display-${saleId}`); display.textContent = "Finalizado!"; document.getElementById(`phase-display-${saleId}`).textContent = "Sessão Concluída"; const startButton = card.querySelector('.start-timer-btn'); startButton.classList.replace('bg-green-500', 'bg-gray-400'); startButton.innerHTML = `<i data-lucide="check-check" class="w-5 h-5"></i> Bronze concluído!`; lucide.createIcons(); }
        
        patioListContainer.addEventListener('click', async (e) => { const target = e.target.closest('button'); if (!target || !currentUser) return; const saleId = target.closest('.timer-section')?.dataset.saleId || target.dataset.id; const saleRef = doc(db, "businesses", currentUser.uid, "sales", saleId); if (target.classList.contains('start-timer-btn')) { await initializeAudio(); const hasPermission = await requestNotificationPermission(); if (Notification.permission === 'default' && !hasPermission) { alert("Para receber alertas, por favor, habilite as permissões."); } const selectedMinutes = document.getElementById(`time-select-${saleId}`).value; await updateDoc(saleRef, { timerState: { status: 'running', currentPhase: 0, phaseDurationSeconds: parseInt(selectedMinutes) * 60, phaseStartedAt: Timestamp.now() } }); } if (target.classList.contains('finish-btn')) { if (!confirm('Confirmar a finalização do serviço?')) return; if (localIntervals[saleId]) { clearInterval(localIntervals[saleId]); delete localIntervals[saleId]; } const cardToRemove = document.getElementById(`sale-${saleId}`); if (cardToRemove) cardToRemove.classList.add('removing'); setTimeout(async () => { await updateDoc(saleRef, { status: "finished", timerState: null }); }, 500); } });
        patioListContainer.addEventListener('change', async (e) => { if (!e.target.classList.contains('time-select') || !currentUser) return; const select = e.target; if (select.disabled) return; const saleId = select.closest('.timer-section').dataset.saleId; const newDurationInSeconds = parseInt(select.value) * 60; const saleRef = doc(db, "businesses", currentUser.uid, "sales", saleId); try { await updateDoc(saleRef, { "timerState.phaseDurationSeconds": newDurationInSeconds }); } catch (error) { console.error("Erro ao atualizar a duração:", error); } });
    </script>
</body>
</html>
